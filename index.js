// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('main', ['firebase', 'ngDraggable']);
x$.controller('main', ['$scope', '$firebaseArray'].concat(function($scope, $firebaseArray){
  var ref, layers, ref$, w, h, padding, bcr, random, build, getpath;
  ref = new Firebase('https://aidraw.firebaseio.com/layers');
  layers = $firebaseArray(ref);
  $scope.layerid = -1;
  $scope.orders = -1;
  $scope.opacity = 0.5;
  $scope.preview = function(){
    return $scope.opacity = $scope.opacity === 0.5 ? 1 : 0.5;
  };
  layers.$watch(function(){
    var i$, to$, i, l;
    $scope.layers = layers;
    if (!$scope.nodes) {
      $scope.nodes = $scope.layers[0];
    }
    $scope.layerid = Math.max.apply(null, layers.map(function(it){
      return it.lid || -1;
    }));
    $scope.orders = Math.max.apply(null, layers.map(function(it){
      return it.order || -1;
    }));
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (!(l.order != null)) {
        l.order = ++$scope.orders;
        $scope.layers.$save(i);
      }
      if (!(l.lid != null)) {
        l.lid = ++$scope.layerid;
        $scope.layers.$save(i);
      }
    }
    if ($scope.nodes) {
      $scope.layer.set($scope.nodes);
    } else {
      $scope.layer.set(0);
    }
    return build();
  });
  $scope.$watch('nodes', function(){
    return $scope.range.update($scope.nodes);
  });
  ref$ = [1024, 600, 60], w = ref$[0], h = ref$[1], padding = ref$[2];
  $scope.chosen = null;
  $scope.layers = layers != null
    ? layers
    : [];
  $scope.setClose = function(){
    $scope.nodes.isClosed = !$scope.nodes.isClosed;
    return build();
  };
  bcr = 4 * (Math.sqrt(2) - 1) / 3;
  $scope.addcircle = function(){
    var ref$, mx, my, r, ret, i$, step$, a;
    ref$ = [1024 / 2, 600 / 2, 50], mx = ref$[0], my = ref$[1], r = ref$[2];
    ret = [];
    for (i$ = 0, step$ = 6.28 / 4; step$ < 0 ? i$ > 6.28 : i$ < 6.28; i$ += step$) {
      a = i$;
      ret.push({
        anchor: [mx + r * Math.cos(a), my + r * Math.sin(a)],
        ctrl1: [Math.cos(a - 6.28 / 4) * r * bcr, Math.sin(a - 6.28 / 4) * r * bcr],
        ctrl2: [-Math.cos(a - 6.28 / 4) * r * bcr, -Math.sin(a - 6.28 / 4) * r * bcr]
      });
    }
    return $scope.layer.add(function(layer){
      var idx;
      idx = $scope.layers.$indexFor(layer);
      layer.isClosed = true;
      layer.points = ret;
      $scope.layers.$save(idx);
      $scope.layer.set(layer);
      return build();
    });
  };
  $scope.addsquare = function(){
    var ref$, mx, my, r, ret;
    ref$ = [1024 / 2, 600 / 2, 50], mx = ref$[0], my = ref$[1], r = ref$[2];
    ret = [
      {
        anchor: [mx - r, my - r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx + r, my - r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx + r, my + r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx - r, my + r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }
    ];
    return $scope.layer.add(function(layer){
      layer.isClosed = true;
      return layer.points = ret;
    });
  };
  $scope.reorder = function(s, d, e){
    var des, desIdx, i$, to$, i, l;
    s = $scope.layers.filter(function(it){
      return it.lid === s;
    })[0].order;
    des = null;
    desIdx = -1;
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (l.order === s) {
        des = l;
        desIdx = i;
      }
      if (l.order > s) {
        l.order--;
        $scope.layers.$save(i);
      }
    }
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (l.order >= d) {
        l.order++;
        $scope.layers.$save(i);
      }
    }
    des.order = d;
    return $scope.layers.$save(desIdx);
  };
  $scope.layer = {
    clone: function(it){
      var ret, ref$, ref1$, res$, i$, len$;
      ret = (ref1$ = {}, ref1$.stroke = (ref$ = $scope.nodes).stroke, ref1$.fill = ref$.fill, ref1$.isClosed = ref$.isClosed, ref1$);
      res$ = [];
      for (i$ = 0, len$ = (ref$ = (ref1$ = $scope.nodes).points || (ref1$.points = [])).length; i$ < len$; ++i$) {
        it = ref$[i$];
        res$.push({
          anchor: it.anchor.slice(),
          ctrl1: it.ctrl1.slice(),
          ctrl2: it.ctrl2.slice()
        });
      }
      ret.points = res$;
      ret.order = ++$scope.orders;
      ret.lid = ++$scope.layerid;
      ret.offset = import$({}, $scope.nodes.offset);
      ret.offset.x += Math.random() * 50 + 20;
      ret.offset.y += Math.random() * 50 + 20;
      return $scope.layers.$add(ret).then(function(ref){
        return $scope.layer.set($scope.layers[$scope.layers.$indexFor(ref.key())]);
      });
    },
    add: function(cb, active){
      var ret;
      cb == null && (cb = null);
      active == null && (active = true);
      ret = {
        points: [],
        stroke: '#000000',
        fill: '#eeeeee',
        order: ++$scope.orders,
        lid: ++$scope.layerid
      };
      return $scope.layers.$add(ret).then(function(ref){
        var idx, obj;
        idx = $scope.layers.$indexFor(ref.key());
        obj = $scope.layers[idx];
        if (active) {
          $scope.layer.set(obj);
        }
        if (cb) {
          return cb(obj);
        }
      });
    },
    remove: function(){
      var order, this$ = this;
      if ($scope.layers.length <= 1) {
        return;
      }
      order = this.target.order;
      return $scope.layers.$remove(this.target).then(function(){
        var min, i$, to$, idx, dis;
        min = {
          dis: -1,
          idx: -1
        };
        for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
          idx = i$;
          dis = Math.abs(order - $scope.layers[idx].order);
          if (min.dis === -1 || dis < min.dis && dis > 0) {
            min.dis = dis;
            min.idx = idx;
          }
        }
        this$.target = $scope.layers[min.idx];
        return this$.set(this$.target);
      });
    },
    set: function(it){
      if (typeof it === typeof 0) {
        this.target = $scope.layers[it];
      } else {
        this.target = it;
      }
      $scope.nodes = this.target;
      $scope.range.update($scope.nodes);
      $scope.path = "";
      return build();
    },
    target: $scope.layers[0],
    buildall: function(){
      var i$, ref$, len$, layer, points, ret, results$ = [];
      for (i$ = 0, len$ = (ref$ = $scope.layers).length; i$ < len$; ++i$) {
        layer = ref$[i$];
        points = layer.points || [];
        if (points.length === 0) {
          continue;
        }
        ret = getpath(points, layer.isClosed);
        results$.push(layer.path = ret);
      }
      return results$;
    }
  };
  $scope.remove = function(){
    if (typeof $scope.chosen === typeof 1 && $scope.chosen < $scope.nodes.points.length) {
      $scope.nodes.points.splice($scope.chosen, 1);
      $scope.chosen = undefined;
    } else {
      $scope.nodes.points.splice(0, 1);
    }
    return build();
  };
  $scope.random = function(){
    random();
    return build();
  };
  random = function(key){
    var ret, ref$;
    ret = {};
    if (typeof key !== "undefined") {
      ret.anchor = [padding + (w - padding * 2) * (key % 2), padding + key * 50];
    } else {
      ret.anchor = [Math.random() * (w - padding * 2) + padding, Math.random() * (h - padding * 2) + padding];
    }
    ret.ctrl1 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    ret.ctrl2 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    ((ref$ = $scope.nodes).points || (ref$.points = [])).push(ret);
    $scope.layers.$save($scope.layers.indexOf($scope.nodes));
    return $scope.range.update($scope.nodes);
  };
  build = function(){
    var ret;
    if (!$scope.nodes || !$scope.nodes.points || $scope.nodes.points.length === 0) {
      return;
    }
    ret = getpath($scope.nodes.points, $scope.nodes.isClosed);
    $scope.path = ret;
    return $scope.layer.buildall();
  };
  getpath = function(points, isClosed){
    var ret, last, i$, to$, i, item, c1x, c1y, c2x, c2y;
    isClosed == null && (isClosed = false);
    ret = "M" + points[0].anchor[0] + " " + points[0].anchor[1];
    last = points[0];
    if (isClosed) {
      points = points.concat([points[0]]);
    }
    for (i$ = 1, to$ = points.length; i$ < to$; ++i$) {
      i = i$;
      item = points[i];
      c1x = last.anchor[0] + last.ctrl2[0];
      c1y = last.anchor[1] + last.ctrl2[1];
      c2x = item.anchor[0] + item.ctrl1[0];
      c2y = item.anchor[1] + item.ctrl1[1];
      ret += "C" + c1x + " " + c1y + " " + c2x + " " + c2y + " " + item.anchor[0] + " " + item.anchor[1];
      last = item;
    }
    return ret;
  };
  $scope.$watch('nodes', function(){
    return build();
  });
  $scope.dragpath = {};
  $scope.ptrctrl = {
    down: function(e){
      var node, ref$, that;
      node = $(e.target);
      if ((node.attr('class') || "").split(' ').indexOf('ctrl') >= 0) {
        $scope.ctrl = node.attr('ctrl');
      }
      if (node.attr('range')) {
        $scope.range.idx = parseInt(node.attr('range'));
      }
      while (node) {
        if (node.attr('idx')) {
          break;
        }
        if ((node.attr('class') || "").split(' ').indexOf('activepath') >= 0) {
          break;
        }
        node = $(node.parent());
        if ((ref$ = node[0].nodeName) === 'BODY' || ref$ === 'SVG') {
          break;
        }
      }
      if ((node.attr('class') || "").split(' ').indexOf('activepath') >= 0) {
        $scope.dragpath.active = true;
        $scope.dragpath.ptr = this.map([e.offsetX, e.offsetY]);
        $scope.dragpath.ptr[0] -= ((ref$ = $scope.nodes).offset || (ref$.offset = {})).x || 0;
        return $scope.dragpath.ptr[1] -= ((ref$ = $scope.nodes).offset || (ref$.offset = {})).y || 0;
      } else if (that = node.attr('idx')) {
        return $scope.idx = $scope.chosen = parseInt(that);
      }
    },
    map: function(arg$){
      var x, y, ref$, w, h, aw, ah, dx, dy;
      x = arg$[0], y = arg$[1];
      ref$ = [$('svg').width(), $('svg').height()], w = ref$[0], h = ref$[1];
      ref$ = [w, h], aw = ref$[0], ah = ref$[1];
      if (w / h > 1024 / 600) {
        w = h * 1024 / 600;
      } else if (w / h < 1024 / 600) {
        h = w * 600 / 1024;
      }
      ref$ = [(aw - w) / 2, (ah - h) / 2], dx = ref$[0], dy = ref$[1];
      x = ((x - dx) / w) * 1024;
      y = ((y - dy) / h) * 600;
      return [x, y];
    },
    remap: function(arg$, os){
      var x, y, rg, dx2, dy2, dx1, dy1;
      x = arg$[0], y = arg$[1];
      rg = $scope.range;
      dx2 = rg.xd - rg.xc;
      dy2 = rg.yd - rg.yc;
      dx1 = rg.xb - rg.xa;
      dy1 = rg.yb - rg.ya;
      if (dx1 !== 0) {
        x = (os.x + x - rg.xa) * dx2 / dx1 + rg.xc - os.x;
      }
      if (dy1 !== 0) {
        y = (os.y + y - rg.ya) * dy2 / dy1 + rg.yc - os.y;
      }
      return [x, y];
    },
    move: function(e){
      var ref$, x, y, idx, rg, rx, ry, xp, yp, os, i$, len$, p, item;
      if (!$scope.nodes) {
        return;
      }
      ref$ = [e.offsetX, e.offsetY], x = ref$[0], y = ref$[1];
      ref$ = this.map([x, y]), x = ref$[0], y = ref$[1];
      if ($scope.range.idx) {
        idx = $scope.range.idx;
        rg = $scope.range;
        rx = [rg.xc, rg.xd];
        ry = [rg.yc, rg.yd];
        xp = idx % 2 ? 0 : 1;
        yp = parseInt(idx / 2) ? 1 : 0;
        rx[xp] = x;
        ry[yp] = y;
        if (rx[1] <= rx[0] + 10) {
          rx[1] = rx[0] + 11;
        }
        if (ry[1] <= ry[0] + 10) {
          ry[1] = ry[0] + 11;
        }
        ref$ = [rx[0], rx[1], ry[0], ry[1]], rg.xc = ref$[0], rg.xd = ref$[1], rg.yc = ref$[2], rg.yd = ref$[3];
        os = $scope.nodes.offset;
        for (i$ = 0, len$ = (ref$ = $scope.nodes.points).length; i$ < len$; ++i$) {
          p = ref$[i$];
          p.ctrl1 = this.remap([p.ctrl1[0] + p.anchor[0], p.ctrl1[1] + p.anchor[1]], os);
          p.ctrl2 = this.remap([p.ctrl2[0] + p.anchor[0], p.ctrl2[1] + p.anchor[1]], os);
          p.anchor = this.remap(p.anchor, os);
          p.ctrl1 = [p.ctrl1[0] - p.anchor[0], p.ctrl1[1] - p.anchor[1]];
          p.ctrl2 = [p.ctrl2[0] - p.anchor[0], p.ctrl2[1] - p.anchor[1]];
        }
        ref$ = [rg.xc, rg.xd, rg.yc, rg.yd], rg.xa = ref$[0], rg.xb = ref$[1], rg.ya = ref$[2], rg.yb = ref$[3];
        build();
        return;
      }
      if ($scope.dragpath.active) {
        $scope.nodes.offset = {
          x: x - $scope.dragpath.ptr[0],
          y: y - $scope.dragpath.ptr[1]
        };
        $scope.range.update($scope.nodes);
        return;
      }
      if ($scope.nodes.offset) {
        ref$ = [x - ($scope.nodes.offset.x || 0), y - ($scope.nodes.offset.y || 0)], x = ref$[0], y = ref$[1];
      }
      item = ((ref$ = $scope.nodes).points || (ref$.points = []))[$scope.idx];
      if (item && !$scope.ctrl) {
        item.anchor[0] = x;
        item.anchor[1] = y;
        build();
      }
      if (item && $scope.ctrl) {
        item["ctrl" + $scope.ctrl][0] = x - item.anchor[0];
        item["ctrl" + $scope.ctrl][1] = y - item.anchor[1];
        return build();
      }
    },
    mup: function(e){
      $scope.range.idx = 0;
      $scope.dragpath.active = false;
      $scope.idx = null;
      $scope.ctrl = null;
      $scope.layers.$save($scope.layers.indexOf($scope.nodes));
      return $scope.range.update($scope.nodes);
    },
    keydown: function(e){
      var keycode;
      keycode = e.keyCode || e.which;
      if (keycode === 8) {
        e.preventDefault();
        return $scope.remove();
      }
    },
    keypress: function(e){}
  };
  ldColorPicker.init();
  $scope.color = {
    setTarget: function(it){
      return this.target = it;
    },
    fill: 'none',
    stroke: 'black'
  };
  $('#fillbtn')[0]._ldcpnode._ldcp.on('change', function(color){
    $scope.$apply(function(){
      if ($scope.nodes && $scope.nodes[$scope.color.target]) {
        return $scope.nodes[$scope.color.target] = color;
      }
    });
    return $scope.layers.$save($scope.layers.indexOf($scope.nodes));
  });
  $scope.range = {
    idx: 0,
    xa: 10,
    ya: 10,
    xb: 100,
    yb: 100,
    xc: 10,
    yc: 10,
    xd: 100,
    yd: 100,
    show: false,
    update: function(node){
      var ps, os, rg, ref$, i$, to$, i, a;
      if (!node) {
        this.show = false;
        return;
      }
      if ((node.points || (node.points = [])).length) {
        this.show = true;
        ps = node.points;
        os = node.offset || (node.offset = {});
        rg = $scope.range;
        ref$ = [ps[0].anchor[0], ps[0].anchor[0], ps[0].anchor[1], ps[0].anchor[1]], rg.xa = ref$[0], rg.xb = ref$[1], rg.ya = ref$[2], rg.yb = ref$[3];
        for (i$ = 0, to$ = ps.length; i$ < to$; ++i$) {
          i = i$;
          a = ps[i].anchor;
          if (a[0] < rg.xa) {
            rg.xa = a[0];
          }
          if (a[0] > rg.xb) {
            rg.xb = a[0];
          }
          if (a[1] < rg.ya) {
            rg.ya = a[1];
          }
          if (a[1] > rg.yb) {
            rg.yb = a[1];
          }
        }
        rg.xa += os.x || 0;
        rg.xb += os.x || 0;
        rg.ya += os.y || 0;
        rg.yb += os.y || 0;
        rg.xa -= 5;
        rg.ya -= 5;
        rg.xb += 5;
        rg.yb += 5;
        return ref$ = [rg.xa, rg.xb, rg.ya, rg.yb], rg.xc = ref$[0], rg.xd = ref$[1], rg.yc = ref$[2], rg.yd = ref$[3], ref$;
      }
    }
  };
  return $('[data-toggle="tooltip"]').tooltip();
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}