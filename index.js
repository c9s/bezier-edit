// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('main', ['firebase']);
x$.controller('main', ['$scope', '$firebaseArray'].concat(function($scope, $firebaseArray){
  var ref$, w, h, padding, random, build, getpath;
  ref$ = [1024, 600, 60], w = ref$[0], h = ref$[1], padding = ref$[2];
  $scope.chosen = null;
  $scope.layers = [{
    points: [],
    stroke: '#000000',
    fill: 'none'
  }];
  $scope.nodes = $scope.layers[0];
  $scope.layer = {
    add: function(){
      return $scope.layers.push({
        points: [],
        stroke: '#000000',
        fill: 'none'
      });
    },
    remove: function(){
      var idx, ref$;
      if ($scope.layers.length <= 1) {
        return;
      }
      idx = $scope.layers.indexOf(this.target);
      $scope.layers.splice(idx, 1);
      this.target = $scope.layers[(ref$ = idx - 1) > 0 ? ref$ : 0];
      return this.set((ref$ = idx - 1) > 0 ? ref$ : 0);
    },
    set: function(it){
      if (typeof it === typeof 0) {
        this.target = $scope.layers[it];
      } else {
        this.target = it;
      }
      return $scope.nodes = this.target;
    },
    target: $scope.layers[0],
    buildall: function(){
      var i$, ref$, len$, layer, points, ret, results$ = [];
      for (i$ = 0, len$ = (ref$ = $scope.layers).length; i$ < len$; ++i$) {
        layer = ref$[i$];
        points = layer.points;
        if (points.length === 0) {
          continue;
        }
        ret = getpath(points);
        results$.push(layer.path = ret);
      }
      return results$;
    }
  };
  $scope.remove = function(){
    if (typeof $scope.chosen === typeof 1 && $scope.chosen < $scope.nodes.points.length) {
      $scope.nodes.points.splice($scope.chosen, 1);
      $scope.chosen = undefined;
    } else {
      $scope.nodes.points.splice(0, 1);
    }
    return build();
  };
  $scope.random = function(){
    random();
    return build();
  };
  random = function(key){
    var ret;
    ret = {};
    if (typeof key !== "undefined") {
      ret.anchor = [padding + (w - padding * 2) * (key % 2), padding + key * 50];
    } else {
      ret.anchor = [Math.random() * (w - padding * 2) + padding, Math.random() * (h - padding * 2) + padding];
    }
    ret.ctrl1 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    ret.ctrl2 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    return $scope.nodes.points.push(ret);
  };
  build = function(){
    var ret;
    if ($scope.nodes.points.length === 0) {
      return;
    }
    ret = getpath($scope.nodes.points);
    $scope.path = ret;
    return $scope.layer.buildall();
  };
  getpath = function(points){
    var ret, last, i$, to$, i, item, c1x, c1y, c2x, c2y;
    ret = "M" + points[0].anchor[0] + " " + points[0].anchor[1];
    last = points[0];
    for (i$ = 1, to$ = points.length; i$ < to$; ++i$) {
      i = i$;
      item = points[i];
      c1x = last.anchor[0] + last.ctrl2[0];
      c1y = last.anchor[1] + last.ctrl2[1];
      c2x = item.anchor[0] + item.ctrl1[0];
      c2y = item.anchor[1] + item.ctrl1[1];
      ret += "C" + c1x + " " + c1y + " " + c2x + " " + c2y + " " + item.anchor[0] + " " + item.anchor[1];
      last = item;
    }
    return ret;
  };
  $scope.$watch('nodes', function(){
    return build();
  });
  $scope.ptrctrl = {
    down: function(e){
      var node, ref$, that;
      node = $(e.target);
      if ((node.attr('class') || "").split(' ').indexOf('ctrl') >= 0) {
        $scope.ctrl = node.attr('ctrl');
      }
      while (node) {
        if (node.attr('idx')) {
          break;
        }
        node = $(node.parent());
        if ((ref$ = node[0].nodeName) === 'BODY' || ref$ === 'SVG') {
          break;
        }
      }
      if (that = node.attr('idx')) {
        return $scope.idx = $scope.chosen = parseInt(that);
      }
    },
    move: function(e){
      var ref$, x, y, w, h, aw, ah, dx, dy, item;
      ref$ = [e.offsetX, e.offsetY], x = ref$[0], y = ref$[1];
      ref$ = [$('svg').width(), $('svg').height()], w = ref$[0], h = ref$[1];
      ref$ = [w, h], aw = ref$[0], ah = ref$[1];
      if (w / h > 1024 / 600) {
        w = h * 1024 / 600;
      } else if (w / h < 1024 / 600) {
        h = w * 600 / 1024;
      }
      ref$ = [(aw - w) / 2, (ah - h) / 2], dx = ref$[0], dy = ref$[1];
      x = ((x - dx) / w) * 1024;
      y = ((y - dy) / h) * 600;
      item = $scope.nodes.points[$scope.idx];
      if (item && !$scope.ctrl) {
        item.anchor[0] = x;
        item.anchor[1] = y;
        build();
      }
      if (item && $scope.ctrl) {
        item["ctrl" + $scope.ctrl][0] = x - item.anchor[0];
        item["ctrl" + $scope.ctrl][1] = y - item.anchor[1];
        return build();
      }
    },
    mup: function(e){
      $scope.idx = null;
      return $scope.ctrl = null;
    },
    keydown: function(e){
      var keycode;
      keycode = e.keyCode || e.which;
      if (keycode === 8) {
        e.preventDefault();
        return $scope.remove();
      }
    },
    keypress: function(e){}
  };
  ldColorPicker.init();
  $scope.color = {
    setTarget: function(it){
      return this.target = it;
    },
    fill: 'none',
    stroke: 'black'
  };
  return $('#fillbtn')[0]._ldcpnode._ldcp.on('change', function(color){
    console.log($scope.color.target, color);
    return $scope.$apply(function(){
      return $scope.nodes[$scope.color.target] = color;
    });
  });
}));