// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('main', ['firebase', 'ngDraggable']);
x$.controller('main', ['$scope', '$firebaseArray'].concat(function($scope, $firebaseArray){
  var ref, layers, ref$, w, h, padding, bcr, random, build, getpath;
  ref = new Firebase('https://aidraw.firebaseio.com/layers');
  layers = $firebaseArray(ref);
  $scope.layerid = -1;
  $scope.orders = -1;
  layers.$watch(function(){
    var i$, to$, i, l;
    $scope.layers = layers;
    if (!$scope.nodes) {
      $scope.nodes = $scope.layers[0];
    }
    $scope.layerid = Math.max.apply(null, layers.map(function(it){
      return it.lid || -1;
    }));
    $scope.orders = Math.max.apply(null, layers.map(function(it){
      return it.order || -1;
    }));
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (!(l.order != null)) {
        l.order = ++$scope.orders;
        $scope.layers.$save(i);
      }
      if (!(l.lid != null)) {
        l.lid = ++$scope.layerid;
        $scope.layers.$save(i);
      }
    }
    return build();
  });
  ref$ = [1024, 600, 60], w = ref$[0], h = ref$[1], padding = ref$[2];
  $scope.chosen = null;
  $scope.layers = layers != null
    ? layers
    : [];
  $scope.setClose = function(){
    $scope.nodes.isClosed = !$scope.nodes.isClosed;
    return build();
  };
  bcr = 4 * (Math.sqrt(2) - 1) / 3;
  $scope.addcircle = function(){
    var ref$, mx, my, r, ret, i$, step$, a, layer;
    ref$ = [1024 / 2, 600 / 2, 50], mx = ref$[0], my = ref$[1], r = ref$[2];
    ret = [];
    for (i$ = 0, step$ = 6.28 / 4; step$ < 0 ? i$ > 6.28 : i$ < 6.28; i$ += step$) {
      a = i$;
      ret.push({
        anchor: [mx + r * Math.cos(a), my + r * Math.sin(a)],
        ctrl1: [Math.cos(a - 6.28 / 4) * r * bcr, Math.sin(a - 6.28 / 4) * r * bcr],
        ctrl2: [-Math.cos(a - 6.28 / 4) * r * bcr, -Math.sin(a - 6.28 / 4) * r * bcr]
      });
    }
    layer = $scope.layer.add();
    layer.isClosed = true;
    console.log('A', ret);
    layer.points = ret;
    console.log('B', layer.points);
    $scope.layers.$save($scope.layers.indexOf(layer));
    $scope.layer.set(layer);
    console.log($scope.layers.indexOf(layer));
    console.log('C', layer);
    return build();
  };
  $scope.addsquare = function(){
    var ref$, mx, my, r, ret, layer;
    ref$ = [1024 / 2, 600 / 2, 50], mx = ref$[0], my = ref$[1], r = ref$[2];
    ret = [
      {
        anchor: [mx - r, my - r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx + r, my - r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx + r, my + r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }, {
        anchor: [mx - r, my + r],
        ctrl1: [0, 0],
        ctrl2: [0, 0]
      }
    ];
    layer = $scope.layer.add();
    layer.isClosed = true;
    return layer.points = ret;
  };
  $scope.reorder = function(s, d, e){
    var des, desIdx, i$, to$, i, l;
    s = $scope.layers.filter(function(it){
      return it.lid === s;
    })[0].order;
    des = null;
    desIdx = -1;
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (l.order === s) {
        des = l;
        desIdx = i;
      }
      if (l.order > s) {
        l.order--;
        $scope.layers.$save(i);
      }
    }
    for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
      i = i$;
      l = $scope.layers[i];
      if (l.order >= d) {
        l.order++;
        $scope.layers.$save(i);
      }
    }
    des.order = d;
    return $scope.layers.$save(desIdx);
  };
  $scope.layer = {
    add: function(){
      var ret, ref$;
      ret = {
        points: [],
        stroke: '#000000',
        fill: 'none',
        order: ++$scope.orders,
        lid: ++$scope.layerid
      };
      $scope.layers.$add(ret);
      $scope.layers.$save($scope.layers.indexOf(ret));
      return (ref$ = $scope.layers)[ref$.length - 1];
    },
    remove: function(){
      var order, idx, canodr, i$, to$, i;
      if ($scope.layers.length <= 1) {
        return;
      }
      order = this.target.order;
      idx = $scope.layers.indexOf(this.target);
      $scope.layers.$remove(idx);
      canodr = -1;
      for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
        i = i$;
        if ($scope.layers[i].order < order && $scope.layers[i].order > canodr) {
          canodr = $scope.layers[i].order;
        }
      }
      if (canodr = -1) {
        canodr = $scope.orders + 1;
        for (i$ = 0, to$ = $scope.layers.length; i$ < to$; ++i$) {
          i = i$;
          if ($scope.layers[i].order > order && $scope.layers[i].order < canodr) {
            canodr = $scope.layers[i].order;
          }
        }
      }
      this.target = $scope.layers.filter(function(it){
        return it.order === canodr;
      })[0];
      idx = $scope.layers.indexOf(this.target);
      return this.set(idx);
    },
    set: function(it){
      if (typeof it === typeof 0) {
        this.target = $scope.layers[it];
      } else {
        this.target = it;
      }
      $scope.nodes = this.target;
      build();
      return $scope.path = "";
    },
    target: $scope.layers[0],
    buildall: function(){
      var i$, ref$, len$, layer, points, ret, results$ = [];
      for (i$ = 0, len$ = (ref$ = $scope.layers).length; i$ < len$; ++i$) {
        layer = ref$[i$];
        points = layer.points || [];
        if (points.length === 0) {
          continue;
        }
        ret = getpath(points, layer.isClosed);
        results$.push(layer.path = ret);
      }
      return results$;
    }
  };
  $scope.remove = function(){
    if (typeof $scope.chosen === typeof 1 && $scope.chosen < $scope.nodes.points.length) {
      $scope.nodes.points.splice($scope.chosen, 1);
      $scope.chosen = undefined;
    } else {
      $scope.nodes.points.splice(0, 1);
    }
    return build();
  };
  $scope.random = function(){
    random();
    return build();
  };
  random = function(key){
    var ret, ref$;
    ret = {};
    if (typeof key !== "undefined") {
      ret.anchor = [padding + (w - padding * 2) * (key % 2), padding + key * 50];
    } else {
      ret.anchor = [Math.random() * (w - padding * 2) + padding, Math.random() * (h - padding * 2) + padding];
    }
    ret.ctrl1 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    ret.ctrl2 = [Math.random() * 100 - 50, Math.random() * 100 - 50];
    ((ref$ = $scope.nodes).points || (ref$.points = [])).push(ret);
    return $scope.layers.$save($scope.layers.indexOf($scope.nodes));
  };
  build = function(){
    var ret;
    if (!$scope.nodes || !$scope.nodes.points || $scope.nodes.points.length === 0) {
      return;
    }
    ret = getpath($scope.nodes.points, $scope.nodes.isClosed);
    $scope.path = ret;
    return $scope.layer.buildall();
  };
  getpath = function(points, isClosed){
    var ret, last, i$, to$, i, item, c1x, c1y, c2x, c2y;
    isClosed == null && (isClosed = false);
    ret = "M" + points[0].anchor[0] + " " + points[0].anchor[1];
    last = points[0];
    if (isClosed) {
      points = points.concat([points[0]]);
    }
    for (i$ = 1, to$ = points.length; i$ < to$; ++i$) {
      i = i$;
      item = points[i];
      c1x = last.anchor[0] + last.ctrl2[0];
      c1y = last.anchor[1] + last.ctrl2[1];
      c2x = item.anchor[0] + item.ctrl1[0];
      c2y = item.anchor[1] + item.ctrl1[1];
      ret += "C" + c1x + " " + c1y + " " + c2x + " " + c2y + " " + item.anchor[0] + " " + item.anchor[1];
      last = item;
    }
    return ret;
  };
  $scope.$watch('nodes', function(){
    return build();
  });
  $scope.dragpath = {};
  $scope.ptrctrl = {
    down: function(e){
      var node, ref$, that;
      node = $(e.target);
      if ((node.attr('class') || "").split(' ').indexOf('ctrl') >= 0) {
        $scope.ctrl = node.attr('ctrl');
      }
      while (node) {
        if (node.attr('idx')) {
          break;
        }
        if ((node.attr('class') || "").split(' ').indexOf('activepath') >= 0) {
          break;
        }
        node = $(node.parent());
        if ((ref$ = node[0].nodeName) === 'BODY' || ref$ === 'SVG') {
          break;
        }
      }
      if ((node.attr('class') || "").split(' ').indexOf('activepath') >= 0) {
        $scope.dragpath.active = true;
        $scope.dragpath.ptr = this.map([e.offsetX, e.offsetY]);
        $scope.dragpath.ptr[0] -= ((ref$ = $scope.nodes).offset || (ref$.offset = {})).x || 0;
        return $scope.dragpath.ptr[1] -= ((ref$ = $scope.nodes).offset || (ref$.offset = {})).y || 0;
      } else if (that = node.attr('idx')) {
        return $scope.idx = $scope.chosen = parseInt(that);
      }
    },
    map: function(arg$){
      var x, y, ref$, w, h, aw, ah, dx, dy;
      x = arg$[0], y = arg$[1];
      ref$ = [$('svg').width(), $('svg').height()], w = ref$[0], h = ref$[1];
      ref$ = [w, h], aw = ref$[0], ah = ref$[1];
      if (w / h > 1024 / 600) {
        w = h * 1024 / 600;
      } else if (w / h < 1024 / 600) {
        h = w * 600 / 1024;
      }
      ref$ = [(aw - w) / 2, (ah - h) / 2], dx = ref$[0], dy = ref$[1];
      x = ((x - dx) / w) * 1024;
      y = ((y - dy) / h) * 600;
      return [x, y];
    },
    move: function(e){
      var ref$, x, y, item;
      if (!$scope.nodes) {
        return;
      }
      ref$ = [e.offsetX, e.offsetY], x = ref$[0], y = ref$[1];
      ref$ = this.map([x, y]), x = ref$[0], y = ref$[1];
      if ($scope.dragpath.active) {
        $scope.nodes.offset = {
          x: x - $scope.dragpath.ptr[0],
          y: y - $scope.dragpath.ptr[1]
        };
        return;
      }
      if ($scope.nodes.offset) {
        ref$ = [x - ($scope.nodes.offset.x || 0), y - ($scope.nodes.offset.y || 0)], x = ref$[0], y = ref$[1];
      }
      item = ((ref$ = $scope.nodes).points || (ref$.points = []))[$scope.idx];
      if (item && !$scope.ctrl) {
        item.anchor[0] = x;
        item.anchor[1] = y;
        build();
      }
      if (item && $scope.ctrl) {
        item["ctrl" + $scope.ctrl][0] = x - item.anchor[0];
        item["ctrl" + $scope.ctrl][1] = y - item.anchor[1];
        return build();
      }
    },
    mup: function(e){
      $scope.dragpath.active = false;
      $scope.idx = null;
      $scope.ctrl = null;
      return $scope.layers.$save($scope.layers.indexOf($scope.nodes));
    },
    keydown: function(e){
      var keycode;
      keycode = e.keyCode || e.which;
      if (keycode === 8) {
        e.preventDefault();
        return $scope.remove();
      }
    },
    keypress: function(e){}
  };
  ldColorPicker.init();
  $scope.color = {
    setTarget: function(it){
      return this.target = it;
    },
    fill: 'none',
    stroke: 'black'
  };
  return $('#fillbtn')[0]._ldcpnode._ldcp.on('change', function(color){
    $scope.$apply(function(){
      if ($scope.nodes && $scope.nodes[$scope.color.target]) {
        return $scope.nodes[$scope.color.target] = color;
      }
    });
    return $scope.layers.$save($scope.layers.indexOf($scope.nodes));
  });
}));